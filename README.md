## Chapter 01_자바 시작
### 컴퓨터와 프로그래밍
- 프로그램 또는 "**소프트웨어**"는 컴퓨터가 이해하고 처리할 수 있는 일련의 명령어들이다.

- 소스 파일을 컴퓨터가 이해할 수 있는 기계어로 변환하는 것을 "**컴파일**"이라고 한다.

- 자바 소스 파일의 확장자는 "**.java**"이고 컴파일된 코드의 확장자는 "**.class**"이다.

### 자바의 출현과 WORA
- 자바는 1991년 선마이크로시스템즈(현재 오라클)의 제임스 고슬링에 의해 개발되기 시작하여 1995년에 발표되었으며, 다양한 플랫폼과 적은 양의 메모리를 갖는 가전제품을 위해 플랫폼 독립적이고 적은 메모리에서도 실행 가능한 언어로 개발되었다.

- C/C++ 등 기존 언어로 개발된 프로그램은 컴파일된 플랫폼에서만 실행되므로 "**플랫폼 종속적**"이다.

- 자바는 한 번 작성하면 하드웨어나 운영체제에 관계없이 실행되는 플랫폼 독립적인 언어이며, 시스템이다. 이런 자바의 특징을 "**WORA**(Write Once Run Anywhere)"라고 부른다.

- 플랫폼 독립성을 실현하기 위해, 각 컴퓨터는 자바 프로그램을 실행하는 "**JVM**(Java Virtual Machine)"이 필요하며, 오라클이 배포하고 있다.

- 컴파일된 자바 코드를 "**바이트 코드**"라고 부르며, JVM(Java Virtual Machine)에서 실행된다.

### 자바 개발 도구
- 자바는 실행 환경에 따라 다양한 배포판을 제공하며, 주요 배포판으로는 데스크톱이나 서버 응용을 위한 Java SE, 모바일 장치를 위한 Java ME, 대규모 기업용 응용을 위한 Java EE가 있다.

- "**JDK**"는 오라클에서 제공하는 자바 프로그램의 개발 도구이며, "**JRE**"는 개발된 자바 프로그램이 실행되기 위해 필요한 제반 환경을 말한다. 개발자에게는 자바 컴파일러와 같은 도구와 개발자가 사용할 수 있는 많은 자바 API가 들어 있는 JDK가 필요하다.

- 자바 API에 대한 문서는 [Version 22 API](https://docs.oracle.com/en/java/javase/22/docs/api/index.html) 에서 온라인으로 참조하면 된다.

### 자바 프로그램 개발
- 자바 클래스의 이름과 자바 소스 파일의 이름은 동일해야 한다. 그래야만 클래스의 바이트 코드가 담긴 클래스 파일을 쉽게 찾을 수 있기 떄문이다. 자바 프로그램은 클래스 선언으로 시작하며, 변수나 메소드는 클래스 내에서만 선언 가능하다. 자바 프로그램의 실행은 "**main()**" 메소드부터 시작한다.

- 이클립스는 자바 소스 편집, 컴파일, 실행, 디버깅을 통합적으로 지원하는 자바 개발 소프트웨어이다.

### 자바 응용프로그램의 종류
- 자바 응용프로그램은 데스크톱에서 실행되는 응용프로그램, 웹 브라우저에서 실행되는 애플릿, 웹 서버에서 실행되는 서블릿, 모바일 단말기에서 실행되는 응용프로그램, 안드로이드 앱 등이 있다.

### 자바의 특징
- 하나의 "**클래스**" 파일에는 반드시 하나의 자바 클래스의 바이트 코드가 들어 있다.

- 자바 언어는 객체 지향, 멀티스레드, 캡슐화, 플랫폼 독립성, 패키지 등을 지원한다.

- 자바로 개발된 응용프로그램은 안전하지만, "**가비지 컬렉션**" 기능으로 인해 실시간 응용에 부적합하다.



## Chapter 02_자바 기본 프로그래밍
### 자바 프로그램의 구조
- 자바 프로그램은 클래스 선언으로 시작되며, 이 안에 메소드, 변수, 상수 등을 모두 선언한다. C/C++에서 말하는 전역 변수, 전역 함수가 존재할 수 없으며, 이들은 반드시 클래스 내에 캡슐화되어야 한다.

- 클래스는 "**class**" 키워드로 선언한다.

- 자바에서 화면에 출력할 때 System.out.println() 문을 사용하면 된다.

### 자바의 데이터 타입
- 자바에는 boolean, char, "**byte**", short, int, long, float, double 등 8개의 기본 타입이 있다.

- 자바에는 클래스에 대한 레퍼런스, 인터페이스에 대한 레퍼런스, "**배열에 대한 레퍼런스**" 등 3가지 종류의 레퍼런스 타입이 있다.

- 레퍼런스 타입은 C/C++의 포인터와 비슷하지만, 실제 메모리 주소를 가지지는 않는다.

- 문자열은 기본 타입이 아니며, 레퍼런스 타입이다.

- 상수는 "**final**" 키워드를 이용하여 초깃값과 함께 선언하며, 프로그램 실행 중에 값이 바뀔 수 없다.

- 작은 데이터 타입에서 큰 데이터 타입으로 타입 변환은 자동으로 일어난다.

- 큰 데이터 타입에서 작은 데이터 타입으로 타입 변환은 명시적으로 지정해야 하며 데이터 손실이 발생할 수 있다.

### 자바에서 키 입력
- System.in은 키보드로부터 직접 입력받는 자바의 표준 입력 스트림 객체로서, 입력된 키에 해당하는 바이트 정보를 리턴한다.

- Scanner 클래스를 이용하면 자바에서 키 입력을 쉽게 받을 수 있다. Scanner 클래스는 입력된 키를 숫자, 문자, 문자열 등 원하는 타입으로 변환하여 제공한다.

- Scanner 객체는 다음과 같이 생성자에 System.in을 넘겨주는 식으로 생성하며, System.in으로부터 전달받은 바이트 스트림을 사용자가 원하는 데이터 타입으로 변환하여 전달한다.
```java
Scanner scanner = new Scanner(System.in);
```

- Scanner 클래스를 사용하려면 Scanner 클래스의 전체 경로명을 알려주는 "**import java.util.Scanner;**" 문이 필요하다.

### 연산자와 조건문
- 자바의 연산자는 C/C++와 거의 동일하며, 산술, 증감, 비교, 시프트, 비트, 논리, 조건, 대입 연산자를 제공한다.

- 자바의 조건문에는 단순 if문, if-else문, 다중 if-else문, 중첩 if-else문, switch문이 있다.

- switch문은 값에 따라 여러 실행 경로로 분기하는 경우에 적합하다.

- switch문은 case에 "**break문**"이 생략되면, 다음 break문을 만날 때까지 아래로 계속 실행된다.

- case문의 값으로는 정수 리터럴, "**문자 리터럴**", 문자열 리터럴만 사용할 수 있으며, 변수나 식은 사용할 수 없다.



## Chapter 03_반복문과 배열 그리고 예외 처리
### 반복문
- 자바의 반복문은 for문, while문, "**do-while**"문으로 3가지이다.

- 반복문 내의 다시 반복문을 사용할 수가 있으며, 이를 중첩 반복문이라 한다.

### continue문과 break문
- continue문과 break문은 반복문 내에 사용된다.
- "**contine**"문은 반복문을 빠져나가지 않고 다음 반복으로 진행된다.
- "**break**"문은 하나의 반복문을 빠져나갈 때 사용한다.

### 배열
- 배열은 같은 종류의 데이터가 순차적으로 연결되어 저장된 자료 구조이다.

- 배열을 만드는 과정은 배열 레퍼런스 변수 선언과 "**배열 생성**"의 두 과정으로 이루어진다. 배열 레퍼번스 변수의 선언은 배열 메모리를 가리키는 레퍼런스(주소와 유사) 값을 가질 변수에 대한 선언이고, 배열 생성은 배열 저장 공간을 확보하는 것이다.

- 공간 4개를 가진 정수형 배열을 만드는 코드 사례는 다음과 같다.
```java
int [] array = new int [4];
```

- 배열 원소에 대한 접근은 배열 레퍼런스 변수명과 [ ] 사이에 원소의 인덱스를 적어 접근한다.

- 배열은 자바에서 객체로 처리된다.

- 배열의 크기는 배열 객체의 "**length**" 필드에 저장되어 있으며, 배열의 인덱스는 0부터 시작한다. 배열은 그 크기를 넘어서 접근하면 실행 중 오류(예외)가 발생한다.

- 자바에서는 다차원 배열을 선언하는 것이 가능하다.

- 메소드가 배열을 리턴하면, 배열의 레퍼런스만 리턴한다.

- "**for-each**"문은 배열의 각 원소를 순차적으로 접근하는 특별한 for문으로써, 정수 배열의 모든 원소를 추력하는 코드 사례는 다음과 같다.
```java
int [] array = {1, 2, 3, 4};
for(int k : array) {System.out.println(k);}
```

### 예외
- 실행 중에 오동작이나 결과에 악영향을 미치는 예상치 못한 오류를 "**예외**"라고 한다.

- 자바 플랫폼은 응용프로그램 실행 중에 발생한 예외(exception)를 응용프로그램에게 전달한다.

- 자바 응용프로그램이 예외 처리 코드를 가지고 있지 않으면, 강제 종료된다.

- 자바는 응용프로그램이 예외를 처리할 수 있도록 try-catch-finally문을 제공한다.

- 예외가 발생할 가능성이 있는 코드는 "**try{ }**" 블록으로 싸고, 예외가 발생할 때 처리하는 코드는 catch() { }블록으로 작성하고, 예외가 발생하든 안 하든 최종적으로 실행할 코드는 finally{ } 블록에 작성한다. finally{ } 블록은 생략 가능하다.

- catch()에서 ( )안에는 처리하고자 하는 예외 타입을 선언한다.

- try 블록 내에서 예외가 발생하면, 발생한 예외 타입과 일치하는 catch 블록으로 점프한다. 일치하는 catch 블록이 없으면, 강제 종료된다.



## Chapter 04_클래스와 객체
### 객체 지향과 자바, 자바 클래스 만들기
- 객체 지향 언어에서는 실제 세상을 모델링하여 객체와 객체 간의 상호 작용으로 나타내며, 캡슐화와 상속, 그리고 "**다형성**" 등 객체에 대한 3가지 특성을 갖는다.

- "**클래스**"는 객체를 생성하기 위한 설계도 또는 틀이라고 볼 수 있으며, 객체는 설계도 또는 틀로 찍어낸 실체라고 볼 수 있다. 객체는 인스턴스라고도 부른다.

- 클래스는 객체들의 특성과 행동을 표현하며, class 키워드로 선언하고 필드(변수)와 메소드(함수)를 포함한다.

- 자바에서 반드시 "**new**" 연산자를 사용하여 객체를 생성한다.

- 객체의 필드나 메소드를 활용할 때는 객체에 대한 레퍼런스 다음에 점(.) 연산자를 이용한다.

### 생성자와 객체 배열
- 생성자는 객체를 생성할 때만 호출되며, 객체를 초기화하기 위한 목적이다.

- 생성자가 선언되지 않는 클래스에는 컴파일러가 자동으로 디폴트 생성자를 삽입한다.

- "**this**"는 현재 실행 문맥을 갖고 있는 객체를 가리키는 레퍼런스이다.

- this()는 다른 "**생성자**"를 호출하는 문장이며, 생성자의 첫 번째 코드로만 사용할 수 있다.

- 객체 배열에서 배열의 원소는 객체에 대한 레퍼런스이다. 객체를 생성하여 객체 배열의 원소에 저장해야 한다.

### 메소드 활용과 객체 치환, 객체 소멸과 가비지 컬렉션
- 자바의 메소드 호출 시 기본 타입의 인자 전달 방식은 "**값에 의한 호출(call by value)**"이다.

- 자바의 메소드 호출 시 객체나 배열을 인자로 전달할 때는 레퍼런스만 전달된다.

- 클래스 내에서 메소드 이름은 같지만 인자의 개수와 타입이 서로 다른 여러 개의 메소드를 작성하는 것을 "**메소드 오버로딩**"이라고 부른다. 이것은 다형성의 한 종류이다.

- 더 이상 참조되지 않는 객체를 "**가비지**"라 하며, 가용 메모리가 일정 수준 이하로 줄어들면 자바 플랫폼에 의해 자동으로 회수된다.

### 접근 지정자
- public으로 선언된 클래스는 다른 어떤 클래스에서도 활용될 수 있지만, 디폴트로 선언된 클래스는 같은 "**패키지**" 내의 클래스들만 활용할 수 있다.

- 멤버의 접근 지정자로는 private, protected, default, public이 있다.

### static과 final
- static 멤버는 객체를 생성하지 않고도 사용할 수 있으며, 동일한 클래스의 객체들 사이에 "**공유**"된다.

- static 멤버들은 클래스당 하나만 생성되므로 "**클래스**" 멤버라고 부르며, 프로그램이 시작될 때 이미 생성되어 객체를 생성하지 않고도 사용할 수 있다. 반면 non-static 멤버는 객체마다 생기기 때문에 인스턴스 멤버라고 부른다.

- final로 선언된 클래스는 더 이상 "**상속**"되지 않으며, final로 선언된 메소드는 더 이상 오버라이딩될 수 없고, final로 선언된 필드는 상수로서, 실행 중에 값을 변경할 수 없다.

## Chapter 05_상속
### 클래스 상속과 객체
- 자바에서 상속은 부모 클래스의 필드와 메소들르 자식 클래스에게 물려주는 것이다. 부모 클래스를 슈퍼 클래스, 자식 클래스를 "**서브 클래스**"라고 한다.

- 자바에서 상속을 선언할 때 "**extends**" 키워드를 사용한다.

### protected 접근 지정, 상속과 생성자
- 서브 클래스에서 슈퍼 클래스의 private 멤버는 접근할 수 없다.

- 슈퍼 클래스의 "**protected**" 멤버는 패키지 소속과 상관없이 서브 클래스에서 접근이 가능하며, 동일한 패키지 내의 클래스에서도 접근이 가능하다.

- 서브 클래스의 인스턴스가 생성되면, 항상 서브 클래스의 생성자 1개와 슈퍼 클래스의 생성자 1개가 실행된다. 이때, 슈퍼 클래스의 생성자가 서브 클래스보다 먼저 실행된다.

- 서브 클래스의 생성자 작성 시, "**super()**"로 슈퍼 클래스의 생성자를 명시적으로 선택한다.

- 만일 슈퍼 클래스의 생성자를 명시적으로 선택하지 않으면, 컴파일러는 슈퍼 클래스의 매개 변수 없는 기본 생성자를 선택한다.

### 업캐스팅과 instanceof 연산자
- 서브 클래스 객체는 슈퍼 클래스 타입으로 자동 타입 변환이 가능하고 이를 "**업캐스팅**"이라 하며, 다시 원래의 타입으로 강제 타입 변환하는 것을 다운캐스팅이라고 한다.

- instanceof 연산자의 결과 값은 "**boolean**" 타입이며, 객체가 어떤 클래스 타입인지 판별할 수 있다.

### 메소드 오버라이딩
- 슈퍼 클래스에 선언된 메소드를 서브 클래스에서 재정의하는 것을 "**메소드 오버라이딩**"이라고 한다.

- 슈퍼 클래스의 메소드를 오버라이딩하면, 서브 클래스에 오버라이딩한 메소드가 항상 실행된다.

- 호출된 메소드를 실행 시간에 찾아서 실행하는 것을 "**동적 바인딩**"이라고 부르며, 오버라이딩된 메소드는 "**동적 바인딩**" 방식으로 호출되고 실행된다.

- "**super**" 키워드는 정적 바인딩으로 슈퍼 클래스에 있는 멤버에 접근할 때 사용한다.

### 추상 클래스와 인터페이스
- 추상 메소드는 실행 코드 없이 원형만 선언된 미완성 메소드이며, 반드시 메소드 이름 앞에 "**abstract**"를 붙여 선언하여야 한다.

- 추상 클래스는 abstract 키워드로 선언된 클래스이며, 최소 1개의 "**추상 메소드**"를 포함하는 경우 반드시 추상 클래스로 선언하여야 한다. 그러나 "**추상 메소드**"가 하나도 없는 경우라도 추상 클래스로 선언할 수 있다.

- 자바에서 인터페이스는 "**interface**" 키워드를 사용하여 선언한다.

- 인터페이스를 구현할 때 "**implements**" 키워드를 사용하며, 인터페이스의 모든 추상 메소드를 구현하여야 한다.

- 추상 클래스와 인터페이스는 인스턴스(객체)를 생성할 수 없다.



## Chapter 06_모듈과 패키지 개념, 자바 패키지 활용
### 패키지
- "**패키지**"란 클래스 또는 인터페이스들을 서로 관련 있는 것들끼리 묶어 놓은 것이다.

- 자바는 다양한 클래스들을 표준 패키지로 묶어 "**rt.jar**" 압축 파일에 제공한다.

- "**import**" 문을 이용하면, 패키지 이름을 생략하고 클래스 이름만 사용할 수 있다.

### 패키지 만들기
- 자바 소스 파일의 맨 첫 줄에 "**package**" 키워드를 이용하여 클래스가 어떤 패키지에 속할지 선언한다. 아래 코드가 컴파일되면 Hello.class 파일은 MyPackage 디렉터리에 저장된다.
```java
package MyPackage;
public class Hello {
    ...
}
```
- 패키지 선언문이 없는 경우 클래스는 "**default**" 패키지에 속하며, 현재 디렉터리에 저장된다.

### 자바 JDK에서 제공하는 패키지
- JDK의 표준 패키지에는 java.lang, java.utill, java.io 등 많은 패키지들이 포함되어 있다.

- "**java.lang**" 패키지의 클래스를 이용할 때는 import문을 생략할 수 있다.

### Object 클래스
- 모든 자바 클래스는 "**Object**" 클래스를 상속받는다.

- 개발자는 클래스에 toString()을 작성하여 객체를 문자열로 리턴하도록 할 수 있다.

- ==는 레퍼런스가 같은지 비교하므로, 두 레퍼런스가 같은 객체를 가리키는지 비교할 때 사용된다.

- 두 객체의 내용물이 같은지 비교하려면, 클래스 내에 "**equals()**" 메소드를 사용해야 한다.

### Wrapper 클래스
- 자바는 int, char 등의 기본 타입의 값을 객체로 다룰 수 있도록 Wrapper 클래스를 제공한다.

- Wrapper에는 Byte, Short, Integer, Long, Character, Float, Double, "**Boolean**"이 있다.

- 기본 타입 값을 Wrapper 객체로 바꾸는 것을 "**박싱**", 그 반대를 "**언박싱**"이라 한다.
```java
Integer n = Integer.valueOf(5);     //박싱
int x = n.intValue();               //언박싱
```

- JDK 1.5부터 자동 박싱과 자동 언박싱이 도입되었다. 이들 사례는 다음과 같다.
```java
Integer n = 5;      //자동 박싱
int x = n;          //자동 언박싱
```

### String, StringBuffer, StringTokenizer, Math 클래스
- String을 이용하여 문자열을 표현하고 문자열을 조작할 수 있다.

- 한 번 만들어진 String 객체의 문자열은 변경할 수 없다.

- StringBuffer는 String 클래스와 달리 내부 버퍼를 가지고 있어, 문자열을 변경할 수 있다.

- Math 클래스는 "**static**" 메소드로만 구성되며, 많은 산술 연산 메소드를 제공한다.



## Chapter 07_컬렉션과 제네릭
### 컬렉션과 제네릭 개념
- `컬렉션`은 요소들의 리스트나 집합을 관리하는 자료 구조로서 크기를 자동 조절하므로, 배열과 달리 요소의 개수에 신경 쓸 필요 없다. 또한, 요소의 추가, 삭제, 검색 등을 쉽게 할 수 있다.

- 주요 컬렉션은 Vector< E >, ArrayList< E >, HashMap< K, V >, LinkedList< E >, Stack< E > 등이다.

- **제네릭**은 일반화시킨 타입의 매개 변수를 이용하여 클래스, 인터페이스, 메소드를 일반화시키는 기법이다. 그러므로 일반화시킨 타입에 구체적인 타입을 지정하여 특정 타입으로만 사용할 수 있다.

- 컬렉션은 JDK 1.5 버전 이후 **제네릭**기법으로 만들어졌다.

- 컬렉션은 구체적인 타입을 지정하여 사용한다. 다음은 Vector< E >를 정수만 처리할 수 있도록 < E >에 Integer 타입을 주어 생성한 코드이다.
```java
Vector<Integer> v = new Vector<Integer>();
```

- 컬렉션의 요소로는 오직 **객체**만 사용된다. int, char, double 등의 기본 타입을 컬렉션의 요소로 삽입하려면 Wrapper 클래스를 이용하여 기본 타입을 객체로 만들어 사용하면 된다.

- JDK 1.5부터는 **자동 박싱/자동 언박싱**이 지원되어 기본 타입을 컬렉션에 바로 삽입하고 추출할 수 있다.

### 제네릭 컬렉션 활용
- **Vector< E >**는 배열을 가변 크기로 다룰 수 있게 한 Vector 컬렉션으로서, 객체의 삽입, 삭제, 이동이 쉽고, 배열처럼 인덱스 번호로 원소를 접근할 수 있다.

- **ArrayList< E >** 역시 배열을 가변 크기로 다룰 수 있게 한 ArrayList 컬렉션으로서, Vector< E >와 거의 유사하나 멀티스레드 동기화를 지원하지 않는다. 다음은 Point 클래스의 객체만 다루는 ArrayList를 생성하는 코드이다.
```java
ArrayList<Point> a = new ArrayList<Point>();
```

- HashMap< K, V >은 **키**와 **값**의 쌍을 하나의 원소로 다루는 HashMap 컬렉선으로서, 인덱스로는 검색할 수 없다. 다음은 키가 문자열이고, 값이 정수인 HashMap을 생성하는 코드이다.
```java
HashMap<String, Integer> h = new Vector<Integer>();
```

- Iterator< E >는 Collection< E > 인터페이스를 구현하여 컬렉션의 원소를 순차적으로 검색할 수 있는 컬렉션이다. Collection< E >를 구현한 모든 컬렉션에 **iterator()** 메소드를 호출하면 Iterator 객체를 리턴하며, 이 객체를 이용하여 인덱스 없이 컬렉션의 요소를 순차 검색할 수 있다.
```java
Vector<Integer> v = new Vector<Integer>();
Iterator<Integer> it = v.iterator();
```

### 제네릭 만들기
- 제네릭 클래스나 인터페이스는 클래스나 인터페이스 이름 다음에 일반화된 타입 매개 변수를 '<'와 '>' 사이에 추가한다.

- 제네릭 타입에 Integer나 String 등의 구체적인 타입을 대입하면, 특정 타입만 다루는 컬렉션 객체가 생성된다.



## Chapter 08_자바 GUI 스윙 기초